import numpy as np
import pandas as pd
import psse3601
import psspy
from dyntools import CHNF
# from .BSPSSEPyGenFunctions import GetGenInfo
from Functions.BSPSSEPy.App.BSPSSEPyAppHelperFunctions import bsprint
import asyncio


async def BuildChannelMapping(OUTFile, DebugPrint=False, app=None):
    """
    Builds a channel mapping from the .out file using dyntools.

    Parameters:
        OUTFile (str): Path to the .out file generated by PSSE.
        DebugPrint (bool): If True, prints detailed debug information.

    Returns:
        dict: A dictionary where keys are descriptive names (e.g., "Frequency Bus 1")
            and values are channel indices.
    
    Notes:
        - This function extracts all available channel data from the .out file
        and organizes it into a dictionary format for quick lookup.
    """
    # Create a CHNF object to read the .out file
    chnf = CHNF(OUTFile)
    short_title, chanid, chandata = chnf.get_data()

    if DebugPrint:
        bsprint("[DEBUG] Short Title:", short_title,app)  # Brief title of the .out file
        await asyncio.sleep(app.bsprintasynciotime if app else 0)
        bsprint("[DEBUG] Channel IDs:", chanid,app)      # Mapping of channel descriptions to indices
        await asyncio.sleep(app.bsprintasynciotime if app else 0)

    # Build the mapping dictionary: {description: index}
    ChannelMapping = {}
    for channel_index, channel_description in chanid.items():
        ChannelMapping[channel_description] = channel_index

    if DebugPrint:
        bsprint("[DEBUG] Channel Mapping Built:",app)
        await asyncio.sleep(app.bsprintasynciotime if app else 0)
        for desc, idx in ChannelMapping.items():
            bsprint(f"    {desc}: Channel {idx}",app)
            await asyncio.sleep(app.bsprintasynciotime if app else 0)

    return ChannelMapping


async def FetchChannelValue(ChannelIndex, OUTFile=None, DebugPrint=False, app=None):
    """
    Attempts to fetch frequency data using psspy.chnval. If it fails, falls back to dyntools.

    Parameters:
        ChannelIndex (int): Channel index for retrieving frequency data via PSSE.
        OUTFile (str, optional): Path to the .out file for fallback in case of errors.
        DebugPrint (bool): If True, prints debug information.

    Returns:
        float: The most recent frequency value.

    Notes:
        - This function first tries to fetch the data using psspy.chnval for real-time values.
        - If psspy.chnval fails, it retrieves the most recent value from the .out file.
    """
    try:
        # Attempt to retrieve the frequency value using psspy.chnval
        ierr, ChannelData = psspy.chnval(ChannelIndex)
        if ierr == 0:
            if DebugPrint:
                bsprint(f"[DEBUG] Retrieved data from chnval: {ChannelData} Hz (Channel {ChannelIndex})",app)
                await asyncio.sleep(app.bsprintasynciotime if app else 0)
            return ChannelData
        else:
            if DebugPrint:
                bsprint(f"[DEBUG] chnval failed for Channel {ChannelIndex}, ierr={ierr}.",app)
                await asyncio.sleep(app.bsprintasynciotime if app else 0)
            # Fallback to .out file if available
            if OUTFile:
                ChannelData = await FetchChannelValuesFromOUTFile(OUTFile, ChannelIndex, DebugPrint,app=app)
                if ChannelData:
                    if DebugPrint:
                        bsprint(f"[DEBUG] Retrieved Frequency from OUT file: {ChannelData[-1]} Hz",app)
                        await asyncio.sleep(app.bsprintasynciotime if app else 0)
                    return ChannelData[-1]  # Return the last value in the time-series
            return 0.0  # Default fallback if all retrieval methods fail
    except Exception as e:
        if DebugPrint:
            bsprint(f"[DEBUG] Error fetching frequency: {e}",app)
            await asyncio.sleep(app.bsprintasynciotime if app else 0)
        return 0.0  # Default fallback in case of an exception
    


async def FetchChannelValuesFromOUTFile(OUTFile, ChannelIndex, DebugPrint=False, app=None):
    """
    Fetches frequency data from the .out file for a specific channel.

    Parameters:
        OUTFile (str): Path to the .out file.
        ChannelIndex (int): The channel index corresponding to the desired frequency data.
        DebugPrint (bool): If True, prints debug information.

    Returns:
        list: Frequency data from the specified channel.

    Notes:
        - This function extracts the entire time-series data for the given channel index.
        - It uses dyntools to read data from the .out file.
    """
    # Create a CHNF object to access .out file data
    chnf = CHNF(OUTFile)
    _, _, chandata = chnf.get_data()

    if DebugPrint:
        bsprint(f"[DEBUG] Fetching frequency data for Channel {ChannelIndex}",app)
        await asyncio.sleep(app.bsprintasynciotime if app else 0)

    # Return the frequency data as a list
    return chandata.get(ChannelIndex, [])



async def GetAvgFrequency(BSPSSEPyGen, Channels, OUTFile = None, DebugPrint=False, app=None):
    
    # Build a mapping of bus numbers to frequency channel indices
    FrequencyChannels = {
        channel["Bus Number"]: channel["Channel Index"]
        for channel in Channels
        if channel["Channel Type"] == "Frequency"
    }

    if DebugPrint:
        bsprint("[DEBUG] Frequency Channels Mapping:", FrequencyChannels,app)
        await asyncio.sleep(app.bsprintasynciotime if app else 0)

    # Fetch frequency deviations for all generators
    GeneratorFrequencies = []
    # for _, GeneratorRow in BSPSSEPyGen[BSPSSEPyGen["BSPSSEPyStatus"]==3].iterrows():
    for _, GeneratorRow in BSPSSEPyGen.iterrows():

        BusNumber = GeneratorRow['NUMBER']
        ChannelIndex = FrequencyChannels.get(BusNumber, None)
        if GeneratorRow["BSPSSEPyStatus"] == 3:    
            if ChannelIndex is not None:
                # Use either the `.out` file or `psspy.chnval` based on the UseOutFile flag
                if OUTFile:
                    FrequencyDeviation = await FetchChannelValuesFromOUTFile(OUTFile, ChannelIndex, DebugPrint,app=app)[-1]
                else:
                    FrequencyDeviation = await FetchChannelValue(ChannelIndex, OUTFile, DebugPrint,app=app)
                    import numpy as np

                    if np.isnan(FrequencyDeviation):
                        bsprint("WARNING: NAN frequency deviation detected. NO AGC Action will be taken.",app)
                        await asyncio.sleep(app.bsprintasynciotime if app else 0)
                        return BSPSSEPyGen


                GeneratorFrequencies.append(FrequencyDeviation)
            else:
                if DebugPrint:
                    bsprint(f"[DEBUG] No frequency channel for Bus {BusNumber}. Defaulting to 0 Hz.",app)
                    await asyncio.sleep(app.bsprintasynciotime if app else 0)
                GeneratorFrequencies.append(0.0)
        else:
            if DebugPrint:
                bsprint(f"[DEBUG] Generator {GeneratorRow['MCNAME']} at Bus {GeneratorRow['NUMBER']} is not in service. The frequency reading won't be used.",app)
                await asyncio.sleep(app.bsprintasynciotime if app else 0)
    

    # Calculate the average system frequency deviation
    AverageFrequencyDeviation = np.mean(GeneratorFrequencies)
    if DebugPrint:
        bsprint(f"[DEBUG] Average Frequency Deviation: {AverageFrequencyDeviation:.6f} Hz",app)
        await asyncio.sleep(app.bsprintasynciotime if app else 0)

    
    return AverageFrequencyDeviation + 60